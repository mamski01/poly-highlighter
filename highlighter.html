<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Image Polygon Highlighter — Demo (v2)</title>
  <style>
    :root { --bg:#0b1020; --panel:#121a2c; --ink:#e6eefc; --muted:#a9b6d3; --accent:#5ea0ff; --accent-2:#7dffcf; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"; color: var(--ink); background: linear-gradient(180deg, #0a0f1f, #060a14 60%); }
    header { padding: 18px 22px; border-bottom: 1px solid #1d2742; background: #0b1326; position: sticky; top: 0; z-index: 10; }
    header h1 { margin: 0; font-size: 18px; letter-spacing: .3px; }

    .app { display: grid; grid-template-columns: 1fr 340px; gap: 16px; padding: 16px; align-items: start; }
    .panel { background: var(--panel); border: 1px solid #1d2742; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,.25); }

    .tools { padding: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; }
    .tools .row { grid-column: 1/-1; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .tools label { font-size: 12px; color: var(--muted); }
    .tools input[type="color"] { width: 44px; height: 34px; border: none; border-radius: 8px; background: #0c152a; padding: 0; cursor: pointer; }
    .btn { cursor: pointer; border: 1px solid #243153; background: #0f1a34; color: var(--ink); padding: 8px 12px; border-radius: 10px; font-size: 13px; }
    .btn:hover { border-color: #315096; }
    .btn.primary { background: linear-gradient(180deg, #163766, #0f2141); border-color: #2f66bf; }
    .toggle.active { outline: 2px solid #2f66bf; }
    .hint { font-size: 12px; color: var(--muted); line-height: 1.5; }

    .stage-wrap { position: relative; border-radius: 12px; overflow: hidden; }
    canvas { display: block; width: 100%; height: auto; background: #061024; cursor: crosshair; }

    .side { padding: 12px; position: sticky; top: 70px; }
    .side h3 { margin: 8px 8px 12px; font-size: 14px; color: var(--muted); font-weight: 600; }
    .preset { border: 1px solid #253253; background: #0e1831; border-radius: 10px; padding: 10px; margin: 8px; }
    .preset header { display:flex; align-items:center; justify-content:space-between; gap: 8px; padding:0; background:none; border:0; position: static; }
    .preset header h4 { margin: 0; font-size: 13px; }
    details { margin-top: 8px; border-top: 1px dashed #263253; padding-top: 8px; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; color: #dfe7ff; }
    pre { margin: 0; max-height: 160px; overflow: auto; background: #0b142c; padding: 8px; border-radius: 8px; }

    .legend { padding: 8px 12px; border-top: 1px solid #1d2742; }
    .legend ul { margin: 8px 0 0; padding-left: 18px; }
    .legend li { font-size: 12px; color: var(--muted); margin: 6px 0; }

    /* Tooltip */
    .tooltip { position: fixed; pointer-events: none; background: #0f2141; color: #dbe6ff; border: 1px solid #244680; padding: 4px 8px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,.35); font-size: 12px; z-index: 1000; transform: translate(-50%, calc(-100% - 8px)); white-space: nowrap; display:none; }
  </style>
</head>
<body>
  <header>
    <h1>Interactive Image Polygon Highlighter — Working Demo (v2)</h1>
  </header>

  <div class="app">
    <section class="panel">
      <div class="tools">
        <div class="row">
          <label for="fill">Fill color</label>
          <input id="fill" type="color" value="#ff7f50" title="Polygon fill color" />

          <label for="polyName">Name</label>
          <input id="polyName" type="text" placeholder="Polygon name (optional)" style="height:34px;border-radius:8px;border:1px solid #243153;background:#0f1a34;color:#e6eefc;padding:0 8px;min-width:160px;" />

          <button id="mode-draw" class="btn toggle active" title="Draw mode (click to add points; double‑click to complete)">Draw</button>
          <button id="mode-move" class="btn toggle" title="Move mode (drag polygons)">Move</button>

          <button id="clear" class="btn" title="Clear current canvas (polygons in progress and unsaved set)">Clear</button>
          <button id="save" class="btn primary" title="Save current set of polygons + background as a preset (S)">Save Preset</button>
        </div>
        <div class="row">
          <label for="bgFile">Background</label>
          <input id="bgFile" type="file" accept="image/*" class="btn" style="padding:6px;" />
          <button id="bgClear" class="btn" title="Remove background image">Remove BG</button>
        </div>
        <div class="row hint">
          Hover to highlight polygons (tooltip shows name). Right‑click a completed polygon to delete it. Press <strong>S</strong> to save as preset. ESC cancels drawing.
        </div>
      </div>

      <div class="stage-wrap">
        <canvas id="stage" width="960" height="560" aria-label="Drawing canvas"></canvas>
        <div id="tooltip" class="tooltip"></div>
      </div>

      <div class="legend">
        <ul>
          <li><strong>Background:</strong> Upload an image (stored in preset as Data URL) or use the default gradient.</li>
          <li><strong>Storage:</strong> In‑memory JSON with normalized coordinates (0–1). Preset includes <code>background</code> and <code>polygons</code>.</li>
          <li><strong>Hover highlight:</strong> outline glow; tooltip shows polygon name.</li>
          <li><strong>Delete:</strong> Right‑click a completed polygon.</li>
          <li><strong>Move mode:</strong> Drag polygons to reposition.</li>
        </ul>
      </div>
    </section>

    <aside class="panel side">
      <h3>Saved Presets</h3>
      <div id="presets"></div>
    </aside>
  </div>

  <script>
    // =================== State ===================
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');

    const ui = {
      color: document.getElementById('fill'),
      name: document.getElementById('polyName'),
      clear: document.getElementById('clear'),
      save: document.getElementById('save'),
      presets: document.getElementById('presets'),
      modeDraw: document.getElementById('mode-draw'),
      modeMove: document.getElementById('mode-move'),
      bgFile: document.getElementById('bgFile'),
      bgClear: document.getElementById('bgClear'),
      tooltip: document.getElementById('tooltip'),
    };

    // Current working polygons on canvas (not yet saved to a preset)
    // Each polygon: { id, name, points: [{x:0..1,y:0..1}], color: "#rrggbb" }
    let polygons = [];
    // Saved presets: [{ id, name, background, polygons }]
    let presets = [];

    const state = {
      mode: 'draw', // 'draw' | 'move'
      isDrawing: false,
      currentPoints: [], // points in pixel coords while drawing
      mouse: { x: 0, y: 0 },
      hoverIndex: null,
      presetCounter: 1,
      dragging: { active: false, polyIndex: null, start:{x:0,y:0} },
    };

    // Background image support
    const background = {
      type: 'gradient-rect', // 'gradient-rect' | 'image'
      image: null,           // HTMLImageElement when loaded
      dataUrl: null,         // persisted in presets
    };

    // =================== Helpers ===================
    const pxToNorm = (p) => ({ x: p.x / canvas.width, y: p.y / canvas.height });
    const normToPx = (p) => ({ x: Math.round(p.x * canvas.width), y: Math.round(p.y * canvas.height) });

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.round((evt.clientX - rect.left) * (canvas.width / rect.width)),
        y: Math.round((evt.clientY - rect.top) * (canvas.height / rect.height))
      };
    }

    function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

    // Ray casting point-in-polygon (expects points in pixel space)
    function pointInPolygon(px, py, pts) {
      let inside = false;
      for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
        const xi = pts[i].x, yi = pts[i].y;
        const xj = pts[j].x, yj = pts[j].y;
        const intersect = ((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / ((yj - yi) || 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function genId() { return crypto.randomUUID ? crypto.randomUUID() : ('p_' + Math.random().toString(36).slice(2)); }

    // =================== Rendering ===================
    function drawBackground() {
      if (background.type === 'image' && background.image && background.image.complete) {
        const img = background.image;
        const imgRatio = img.width / img.height;
        const canRatio = canvas.width / canvas.height;
        let dw = canvas.width, dh = canvas.height, dx = 0, dy = 0;
        if (imgRatio > canRatio) { dh = canvas.height; dw = Math.ceil(dh * imgRatio); dx = Math.round((canvas.width - dw)/2); }
        else { dw = canvas.width; dh = Math.ceil(dw / imgRatio); dy = Math.round((canvas.height - dh)/2); }
        ctx.drawImage(img, dx, dy, dw, dh);
      } else {
        const g = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        g.addColorStop(0, '#0b1f56'); g.addColorStop(.5, '#0d2d7a'); g.addColorStop(1, '#0a1c49');
        ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save(); ctx.globalAlpha = 0.08; ctx.strokeStyle = '#cfe2ff'; ctx.lineWidth = 1;
        for (let x = 0; x < canvas.width; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
        for (let y = 0; y < canvas.height; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        ctx.restore();
      }
    }

    function drawPolygon(poly, { highlight = false } = {}) {
      const pts = poly.points.map(normToPx);
      if (pts.length < 3) return;

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();

      ctx.save();
      ctx.globalAlpha = 0.35; // base translucency
      ctx.fillStyle = poly.color;
      ctx.fill();
      ctx.restore();

      // Base outline
      ctx.lineJoin = 'round';
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0b0f18';
      ctx.stroke();

      // Hover outline glow
      if (highlight) {
        ctx.save(); ctx.lineJoin = 'round'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4; ctx.globalAlpha = 0.9; ctx.stroke(); ctx.restore();
      }
    }

    function drawInProgress(points) {
      if (!points.length) return;
      ctx.save(); ctx.setLineDash([6, 6]); ctx.lineWidth = 2; ctx.strokeStyle = '#9dccff';
      ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.lineTo(state.mouse.x, state.mouse.y); ctx.stroke(); ctx.restore();

      ctx.save(); ctx.fillStyle = '#e6f2ff';
      for (const p of points) { ctx.beginPath(); ctx.arc(p.x, p.y, 3.5, 0, Math.PI * 2); ctx.fill(); }
      ctx.restore();

      ctx.save(); ctx.strokeStyle = '#7dffcf'; ctx.beginPath(); ctx.arc(points[0].x, points[0].y, 7, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      for (let i = 0; i < polygons.length; i++) { drawPolygon(polygons[i], { highlight: i === state.hoverIndex }); }
      if (state.isDrawing) drawInProgress(state.currentPoints);
    }

    // =================== Events ===================
    canvas.addEventListener('mousemove', (e) => {
      state.mouse = getMousePos(e);

      // Hover detection (top‑most first)
      state.hoverIndex = null;
      for (let i = polygons.length - 1; i >= 0; i--) {
        const ptsPx = polygons[i].points.map(normToPx);
        if (pointInPolygon(state.mouse.x, state.mouse.y, ptsPx)) { state.hoverIndex = i; break; }
      }

      // Tooltip
      if (state.hoverIndex !== null && !state.isDrawing) {
        const poly = polygons[state.hoverIndex];
        ui.tooltip.textContent = poly.name || 'Polygon';
        ui.tooltip.style.left = e.clientX + 'px';
        ui.tooltip.style.top = e.clientY + 'px';
        ui.tooltip.style.display = 'block';
      } else {
        ui.tooltip.style.display = 'none';
      }

      // Dragging in move mode
      if (state.mode === 'move' && state.dragging.active && state.dragging.polyIndex !== null) {
        const dx = e.movementX * (canvas.width / canvas.getBoundingClientRect().width);
        const dy = e.movementY * (canvas.height / canvas.getBoundingClientRect().height);
        const poly = polygons[state.dragging.polyIndex];
        // Move by adjusting normalized points by delta
        for (let p of poly.points) {
          p.x = Math.min(1, Math.max(0, p.x + dx / canvas.width));
          p.y = Math.min(1, Math.max(0, p.y + dy / canvas.height));
        }
      }

      render();
    });

    canvas.addEventListener('mousedown', (e) => {
      if (state.mode === 'move') {
        // pick polygon for dragging
        const pos = getMousePos(e);
        for (let i = polygons.length - 1; i >= 0; i--) {
          const ptsPx = polygons[i].points.map(normToPx);
          if (pointInPolygon(pos.x, pos.y, ptsPx)) {
            state.dragging.active = true; state.dragging.polyIndex = i; state.dragging.start = pos; break;
          }
        }
      }
    });

    document.addEventListener('mouseup', () => {
      state.dragging.active = false; state.dragging.polyIndex = null;
    });

    canvas.addEventListener('click', (e) => {
      if (state.mode !== 'draw') return; // drawing only in draw mode
      const p = getMousePos(e);
      if (!state.isDrawing) { state.isDrawing = true; state.currentPoints = [p]; }
      else { state.currentPoints.push(p); }
      render();
    });

    canvas.addEventListener('dblclick', () => {
      if (state.mode !== 'draw') return;
      if (state.isDrawing && state.currentPoints.length >= 3) {
        const normPts = state.currentPoints.map(pxToNorm);
        const color = ui.color.value;
        const name = (ui.name.value || '').trim() || `Polygon ${polygons.length + 1}`;
        polygons.push({ id: genId(), name, points: normPts, color });
        state.isDrawing = false; state.currentPoints = []; ui.name.value = '';
        render();
      }
    });

    // Right‑click delete completed polygon
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (state.isDrawing) return; // ignore while drawing
      const pos = getMousePos(e);
      for (let i = polygons.length - 1; i >= 0; i--) {
        const ptsPx = polygons[i].points.map(normToPx);
        if (pointInPolygon(pos.x, pos.y, ptsPx)) {
          if (confirm(`Delete polygon "${polygons[i].name || ''}"?`)) { polygons.splice(i, 1); render(); }
          return;
        }
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 's') { e.preventDefault(); onSavePreset(); }
      if (e.key === 'Escape' && state.isDrawing) { state.isDrawing = false; state.currentPoints = []; render(); }
    });

    // Buttons
    ui.clear.addEventListener('click', () => { state.isDrawing = false; state.currentPoints = []; polygons = []; render(); });
    ui.save.addEventListener('click', onSavePreset);

    ui.modeDraw.addEventListener('click', () => setMode('draw'));
    ui.modeMove.addEventListener('click', () => setMode('move'));

    function setMode(m) {
      state.mode = m;
      ui.modeDraw.classList.toggle('active', m === 'draw');
      ui.modeMove.classList.toggle('active', m === 'move');
      canvas.style.cursor = (m === 'move') ? 'grab' : 'crosshair';
      // Cancel in-progress drawing if switching to move
      if (m === 'move' && state.isDrawing) { state.isDrawing = false; state.currentPoints = []; }
      render();
    }

    // Background upload/clear
    ui.bgFile.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        background.type = 'image';
        background.dataUrl = reader.result;
        const img = new Image();
        img.onload = () => { background.image = img; render(); };
        img.src = background.dataUrl;
      };
      reader.readAsDataURL(file);
    });
    ui.bgClear.addEventListener('click', () => { background.type = 'gradient-rect'; background.image = null; background.dataUrl = null; render(); });

    function onSavePreset() {
      if (state.isDrawing && state.currentPoints.length > 0) { return flashHint('Finish the polygon with a double‑click before saving.'); }
      if (polygons.length === 0 && !background.dataUrl) { return flashHint('Nothing to save — add a polygon or a background image.'); }
      const data = deepClone({
        background: background.type === 'image' ? { type: 'image', dataUrl: background.dataUrl } : { type: 'gradient-rect' },
        polygons,
      });
      const id = genId();
      const name = `Preset ${state.presetCounter++}`;
      presets.push({ id, name, ...data });
      addPresetCard({ id, name, ...data });
      // Clear current set after saving
      polygons = [];
      render();
    }

    function flashHint(msg) {
      const t = document.createElement('div');
      t.textContent = msg;
      Object.assign(t.style, { position: 'fixed', bottom: '16px', left: '50%', transform: 'translateX(-50%)', background: '#0f2141', color: '#dbe6ff', border: '1px solid #244680', padding: '8px 12px', borderRadius: '10px', boxShadow: '0 10px 30px rgba(0,0,0,.35)', zIndex: 1000, fontSize: '13px' });
      document.body.appendChild(t); setTimeout(() => t.remove(), 1800);
    }

    // =================== Presets UI ===================
    function addPresetCard(preset) {
      const card = document.createElement('div'); card.className = 'preset'; card.dataset.id = preset.id;
      const polyCount = preset.polygons ? preset.polygons.length : 0;
      const hasBG = (preset.background && preset.background.type === 'image');
      card.innerHTML = `
        <header>
          <h4>${preset.name}</h4>
          <div>
            <button class="btn" data-cmd="load">Load</button>
          </div>
        </header>
        <div class="hint">${polyCount} polygon(s) • BG: ${hasBG ? 'image' : 'gradient'}</div>
        <details>
          <summary>View JSON</summary>
          <pre><code></code></pre>
        </details>
      `;
      const code = card.querySelector('code');
      code.textContent = JSON.stringify({ background: preset.background, polygons: preset.polygons }, null, 2);

      card.addEventListener('click', (e) => {
        const cmd = e.target.getAttribute('data-cmd');
        if (cmd === 'load') {
          const found = presets.find(p => p.id === preset.id);
          if (found) {
            // Load background
            if (found.background && found.background.type === 'image' && found.background.dataUrl) {
              background.type = 'image'; background.dataUrl = found.background.dataUrl; const img = new Image(); img.onload = () => { background.image = img; render(); }; img.src = background.dataUrl;
            } else { background.type = 'gradient-rect'; background.dataUrl = null; background.image = null; }
            // Load polygons
            polygons = deepClone(found.polygons || []);
            state.isDrawing = false; state.currentPoints = [];
            render();
          }
        }
      });
      ui.presets.prepend(card);
    }

    // =================== Init ===================
    function init() { render(); }
    init();
  </script>
</body>
</html>
